

## 补充

### F3 更新部分

#### 方案4 公钥证书

引入签发中心CA，CA确认用户的身份后可以向用户颁发证书。
一份数字证书有两个目标：

1. 提供一个密钥，使得证书使用者可以将数据加密后发送给证书持有者；
2. 提供一种证据，证明证书持有者就是所声称的那个人（认证）。

下面是一个证书签发的例子：

C_A = E(PR_auth, [T || ID_A || PU_a])

如果用户A持有一个CA1签发的证书，用户B同样持有CA1签发的证书，当用户A想要给用户B发送消息时，可以直接获取用户B的证书，然后使用CA1的公钥验证签名。

如果用户A和B分别持有CA1和CA2签发的证书，那么A获取到B的证书后还需要安全获取CA2的公钥。如果CA2持有一个CA1签发的证书，A就可以确认这一点。

```
CA1<<CA2>>CA2<<B>>
```

使用数字证书分发公钥，就不需要依赖一个持续在线的管理员。

但是实际使用中可能发生意外，比如CA签发证书后认为用户不再安全，或是用户泄露了自己的私钥等。这时就需要CA提供证书吊销列表。证书吊销列表中包含证书的序列号和吊销时间。当用户收到证书时需要检查证书是否被吊销。


### 2021 剩余题目

#### 2021-Final-5


全局参数：p,q,g
私钥：x
公钥：y = pow(g, x, p)

签名过程：
r = pow(g, k, p)
e = H(r||M)
s = k - e*x mod q
公开(e,s)对。

1. 验签过程：

```
计算r' = g^s * y^e % p, 验证H(r'||M)和e是否相等。
如果公钥正确，则:
r'= g^(k-e*x) * g^(e*x) % p
  = g^k % p
  = r
```

2&3 如果重用K

```
如果重用k,产生(e1,s1) (e2,s2)
则s2-s1 = (e1-e2)*x mod q

s2 = k - e2*x mod q
s1 = k - e1*x mod q

c1 = a*m1 + b mod q
c2 = a*m2 + b mod q


则(s2-s1)*inverse(e1-e1, q) = x mod q
左边都是已知量，可以恢复私钥。
```

4. 依然可以攻击：

```
对于这样的(e1,s1) (e2,s2)
s2-s1 = (k2-k1)+(e1-e2)*x mod q
(s2-s1+k1-k2)*inverse(e1-e1, q) = x mod q
其中:
k1 = z + i
k2 = z + j
所以k1-k2 = j-i
左边依然都是已知量，可以恢复私钥。
```

#### 2021-Final-8


1

在密码学中，累加器是单向成员散列函数。它允许用户证明潜在的元素是某个集合的成员，而不必透露集合中的其他信息。

这个问题讨论到Merkle树和RSA累加器。

Merkle 树基于哈希值建立一个树结构，如对于消息 M1 M2 M3 M4 计算：

```
H1-1 = HASH(M1) H1-2 = HASH(M2) ...
H2-1 = HASH(H1-1||H1-2) ...
H3-1 = HASH(H2-1||H2-1)

如果要证明 M1 在集合中，只要提供 H1-2 H2-2 H3-1 即可，不会透露出集合其他任何元素的信息。

A 知道集合内容，算出需要的哈希，给B。

B 只有M1 想要确认 M1 是否在集合中。使用M1和其它哈希最终计算 H3-1 并对比。
```

RSA 累加器如题目描述，对于消息 X1 X2 X3 X4 计算：

```
A = pow(g, X1*X2*X3*X4, n)

如果要证明 X1 在集合中，只要提供 A 和 PI = pow(g, X2*X3*X4, n) 即可，不会透露出集合其他任何元素的信息。
```

那么如果集合有n个元素，计算凭证生成时间都是线性级别，二者都可以并行加速，而Merkle树需要的验证时间是 logn 级别的（不可并行），RSA 累加器是常数时间（无需并行）。


2

可以在常数时间增加元素

如果需要删除元素，需要重新计算 g 的剩余元素积次方，需要线性时间，但是如果有以树状结构缓存的中间结果，则可以以 logn 时间计算。

3

如果知道 n 的分解，就可以直接计算 x 对 phin 的逆元 x'，（A，pow(A, x', n)） 是一个必然通过证明。
因为pow(pow(A, x', n), x, n）= A。

### 群问题整理

#### GF 计算

```
Consider GF(2^3) = GF(2)[x] mod (x^3 + x^2 + 1), a field with 8 elements.
Express all the elements of GF(2^3) = GF(2)[x] mod (x^3 + x^2 + 1) as polynomials.
```

- 系数对 p 取模，这里是 2 *
- 如果多项式最高次数大于等于 n，对不可约多项式取模

- 计算和不可约多项式有很强的关联性，指定题目中的多项式，不要使用sage默认的
- 如果使用sage，数组方式输入多项式系数从低次到高次，推荐直接使用多项式方式



#### 快速幂的时间估计

logn到2倍logn之间


``` python
pow(m, d, n)
t = 1
# 遍历了d的二进制比特, 循环次数为 log(d)
for bit in d:
    # 如果遇到 1, 额外进行一次乘法
	if bit == 1:
		t *= m
	# 必然进行的乘法
    m *= m
```

- 可以看到如果 d 中 比特1最少（1个） 则进行 log(d)+1 次乘法
- 如果最多(全是1) 则进行 log(d)+log(d) 次乘法

#### RSA e和d 的关系以及取最小d问题


1. 生成 p, q
2. 计算 n = p\*q
3. 计算 n 的欧拉函数, phin = (p-1)\*(q-1)
4. 生成公钥 e，和 phin 互素即可
5. 计算私钥 d，满足 e*d % phin = 1, 例如 d = inverse(e, phin)
6. 丢弃 phin p q
7. 保留 e, n 作为公钥， d 作为私钥

e 和 d 的要求是 e*d mod phin == 1，因为乘法具有交换律，二者实际没有区别，如果大小都合适，只要任意公开一个即可。

但是 实际作为私钥的指数不能太小，已经有针对小私钥指数的攻击。

#### 古典密码密钥空间分析

- 栅栏
- 如果在考试中遇到说置换密码的，实际就是这个：

```
复杂的置换

- 类比栅栏，可以认为是纵向写，横向按照特定顺序读
- key的长度为栅栏深度，key的内容为读的顺序
- 加密

  明文: abcdefg
  key为：[2,1]
  加密:
  2 a c e g
  1 b d f
  密文：bdfaceg
  对于一个密钥长度为n的置换加密，n!。
```

就算 key 是自然顺序，复杂的置换也是一个栅栏，这种场景不是平凡密钥。

#### fiestel 结构补充

- 关于key的顺序: 使用key的顺序和明文到密文的顺序一致，靠近明文的 key 序号小，靠近密文的key 序号大。
- 画解密图的时候，F函数的输入应该来自靠近密文的分组，因为是先有密文，后有明文。
